"use strict";
/* ============================================================================
 * Copyright (c) Palo Alto Networks
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 * ========================================================================== */
var __createBinding =
  (this && this.__createBinding) ||
  (Object.create
    ? function (o, m, k, k2) {
        if (k2 === undefined) k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (
          !desc ||
          ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)
        ) {
          desc = {
            enumerable: true,
            get: function () {
              return m[k];
            },
          };
        }
        Object.defineProperty(o, k2, desc);
      }
    : function (o, m, k, k2) {
        if (k2 === undefined) k2 = k;
        o[k2] = m[k];
      });
var __setModuleDefault =
  (this && this.__setModuleDefault) ||
  (Object.create
    ? function (o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
      }
    : function (o, v) {
        o["default"] = v;
      });
var __importStar =
  (this && this.__importStar) ||
  (function () {
    var ownKeys = function (o) {
      ownKeys =
        Object.getOwnPropertyNames ||
        function (o) {
          var ar = [];
          for (var k in o)
            if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
          return ar;
        };
      return ownKeys(o);
    };
    return function (mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null)
        for (var k = ownKeys(mod), i = 0; i < k.length; i++)
          if (k[i] !== "default") __createBinding(result, mod, k[i]);
      __setModuleDefault(result, mod);
      return result;
    };
  })();
var __importDefault =
  (this && this.__importDefault) ||
  function (mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
Object.defineProperty(exports, "__esModule", { value: true });
const react_1 = __importStar(require("react"));
const Translate_1 = require("@docusaurus/Translate");
const slice_1 = require("@theme/ApiExplorer/SchemaSelection/slice");
const hooks_1 = require("@theme/ApiItem/hooks");
const ArrayBrackets_1 = require("@theme/ArrayBrackets");
const Details_1 = __importDefault(require("@theme/Details"));
const DiscriminatorTabs_1 = __importDefault(
  require("@theme/DiscriminatorTabs")
);
const Markdown_1 = __importDefault(require("@theme/Markdown"));
const SchemaItem_1 = __importDefault(require("@theme/SchemaItem"));
const SchemaTabs_1 = __importDefault(require("@theme/SchemaTabs"));
const TabItem_1 = __importDefault(require("@theme/TabItem"));
const translationIds_1 = require("@theme/translationIds");
// eslint-disable-next-line import/no-extraneous-dependencies
const allof_merge_1 = require("allof-merge");
const clsx_1 = __importDefault(require("clsx"));
const schema_1 = require("docusaurus-plugin-openapi-docs/lib/markdown/schema");
const isEmpty_1 = __importDefault(require("lodash/isEmpty"));
// eslint-disable-next-line import/no-extraneous-dependencies
// const jsonSchemaMergeAllOf = require("json-schema-merge-allof");
const mergeAllOf = (allOf) => {
  const onMergeError = (msg) => {
    console.warn(msg);
  };
  const mergedSchemas = (0, allof_merge_1.merge)(allOf, { onMergeError });
  return mergedSchemas;
};
// Renders string as markdown, useful for descriptions and qualifiers
const MarkdownWrapper = ({ text }) => {
  return react_1.default.createElement(
    "div",
    { style: { marginTop: ".5rem", marginBottom: ".5rem" } },
    react_1.default.createElement(Markdown_1.default, null, text)
  );
};
const Summary = ({ name, schemaName, schema, required }) => {
  const { deprecated, nullable } = schema;
  const isRequired = Array.isArray(required)
    ? required.includes(name)
    : required === true;
  return react_1.default.createElement(
    "summary",
    null,
    react_1.default.createElement(
      "span",
      { className: "openapi-schema__container" },
      react_1.default.createElement(
        "strong",
        {
          className: (0, clsx_1.default)("openapi-schema__property", {
            "openapi-schema__strikethrough": deprecated,
          }),
        },
        name
      ),
      react_1.default.createElement(
        "span",
        { className: "openapi-schema__name" },
        " ",
        schemaName
      ),
      (isRequired || deprecated || nullable) &&
        react_1.default.createElement("span", {
          className: "openapi-schema__divider",
        }),
      nullable &&
        react_1.default.createElement(
          "span",
          { className: "openapi-schema__nullable" },
          (0, Translate_1.translate)({
            id: translationIds_1.OPENAPI_SCHEMA_ITEM.NULLABLE,
            message: "nullable",
          })
        ),
      isRequired &&
        react_1.default.createElement(
          "span",
          { className: "openapi-schema__required" },
          (0, Translate_1.translate)({
            id: translationIds_1.OPENAPI_SCHEMA_ITEM.REQUIRED,
            message: "required",
          })
        ),
      deprecated &&
        react_1.default.createElement(
          "span",
          { className: "openapi-schema__deprecated" },
          (0, Translate_1.translate)({
            id: translationIds_1.OPENAPI_SCHEMA_ITEM.DEPRECATED,
            message: "deprecated",
          })
        )
    )
  );
};
const AnyOneOf = ({ schema, schemaType, schemaPath }) => {
  const key = schema.oneOf ? "oneOf" : "anyOf";
  const type = schema.oneOf
    ? (0, Translate_1.translate)({
        id: translationIds_1.OPENAPI_SCHEMA_ITEM.ONE_OF,
        message: "oneOf",
      })
    : (0, Translate_1.translate)({
        id: translationIds_1.OPENAPI_SCHEMA_ITEM.ANY_OF,
        message: "anyOf",
      });
  // Generate a unique ID for this anyOf/oneOf to prevent tab value collisions
  const uniqueId = react_1.default.useMemo(
    () => Math.random().toString(36).substring(7),
    []
  );
  // Try to get Redux dispatch - will be undefined if not inside a Provider
  let dispatch;
  try {
    // eslint-disable-next-line react-hooks/rules-of-hooks
    dispatch = (0, hooks_1.useTypedDispatch)();
  } catch {
    // Not inside a Redux Provider, which is fine for response schemas
    dispatch = undefined;
  }
  // Handle tab change - dispatch to Redux if schemaPath is provided
  const handleTabChange = (0, react_1.useCallback)(
    (index) => {
      if (schemaPath && dispatch) {
        dispatch((0, slice_1.setSchemaSelection)({ path: schemaPath, index }));
      }
    },
    [schemaPath, dispatch]
  );
  return react_1.default.createElement(
    react_1.default.Fragment,
    null,
    react_1.default.createElement(
      "span",
      { className: "badge badge--info", style: { marginBottom: "1rem" } },
      type
    ),
    react_1.default.createElement(
      SchemaTabs_1.default,
      { groupId: `schema-${uniqueId}`, lazy: true, onChange: handleTabChange },
      schema[key]?.map((anyOneSchema, index) => {
        // Use getSchemaName to include format info (e.g., "string<date-time>")
        const computedSchemaName = (0, schema_1.getSchemaName)(anyOneSchema);
        // Determine label for the tab
        // Prefer explicit title, then computed schema name, then raw type
        let label =
          anyOneSchema.title || computedSchemaName || anyOneSchema.type;
        if (!label) {
          if (anyOneSchema.oneOf) {
            label = (0, Translate_1.translate)({
              id: translationIds_1.OPENAPI_SCHEMA_ITEM.ONE_OF,
              message: "oneOf",
            });
          } else if (anyOneSchema.anyOf) {
            label = (0, Translate_1.translate)({
              id: translationIds_1.OPENAPI_SCHEMA_ITEM.ANY_OF,
              message: "anyOf",
            });
          } else {
            label = `Option ${index + 1}`;
          }
        }
        // Build the nested schemaPath for child anyOf/oneOf
        const childSchemaPath = schemaPath
          ? `${schemaPath}.${index}`
          : undefined;
        return (
          // @ts-ignore
          react_1.default.createElement(
            TabItem_1.default,
            { key: index, label: label, value: `${uniqueId}-${index}-item` },
            (isPrimitive(anyOneSchema) || anyOneSchema.const) &&
              react_1.default.createElement(SchemaItem_1.default, {
                collapsible: false,
                name: undefined,
                schemaName: computedSchemaName,
                qualifierMessage: (0, schema_1.getQualifierMessage)(
                  anyOneSchema
                ),
                schema: anyOneSchema,
                discriminator: false,
                children: null,
              }),
            anyOneSchema.type === "object" &&
              !anyOneSchema.properties &&
              !anyOneSchema.allOf &&
              !anyOneSchema.oneOf &&
              !anyOneSchema.anyOf &&
              react_1.default.createElement(SchemaItem_1.default, {
                collapsible: false,
                name: undefined,
                schemaName: computedSchemaName,
                qualifierMessage: (0, schema_1.getQualifierMessage)(
                  anyOneSchema
                ),
                schema: anyOneSchema,
                discriminator: false,
                children: null,
              }),
            (anyOneSchema.type === "object" || !anyOneSchema.type) &&
              anyOneSchema.properties &&
              react_1.default.createElement(Properties, {
                schema: anyOneSchema,
                schemaType: schemaType,
                schemaPath: childSchemaPath,
              }),
            anyOneSchema.allOf &&
              react_1.default.createElement(SchemaNode, {
                schema: anyOneSchema,
                schemaType: schemaType,
                schemaPath: childSchemaPath,
              }),
            anyOneSchema.oneOf &&
              react_1.default.createElement(SchemaNode, {
                schema: anyOneSchema,
                schemaType: schemaType,
                schemaPath: childSchemaPath,
              }),
            anyOneSchema.anyOf &&
              react_1.default.createElement(SchemaNode, {
                schema: anyOneSchema,
                schemaType: schemaType,
                schemaPath: childSchemaPath,
              }),
            anyOneSchema.items &&
              react_1.default.createElement(Items, {
                schema: anyOneSchema,
                schemaType: schemaType,
                schemaPath: childSchemaPath,
              })
          )
        );
      })
    )
  );
};
const Properties = ({ schema, schemaType, schemaPath }) => {
  const discriminator = schema.discriminator;
  if (discriminator && !discriminator.mapping) {
    const anyOneOf = schema.oneOf ?? schema.anyOf ?? {};
    const inferredMapping = {};
    Object.entries(anyOneOf).map(([_, anyOneSchema]) => {
      // ensure discriminated property only renders once
      if (
        schema.properties[discriminator.propertyName] &&
        anyOneSchema.properties[discriminator.propertyName]
      )
        delete anyOneSchema.properties[discriminator.propertyName];
      return (inferredMapping[anyOneSchema.title] = anyOneSchema);
    });
    discriminator["mapping"] = inferredMapping;
  }
  if (Object.keys(schema.properties).length === 0) {
    return react_1.default.createElement(SchemaItem_1.default, {
      collapsible: false,
      name: "",
      required: false,
      schemaName: "object",
      qualifierMessage: undefined,
      schema: {},
    });
  }
  return react_1.default.createElement(
    react_1.default.Fragment,
    null,
    Object.entries(schema.properties).map(([key, val]) =>
      react_1.default.createElement(SchemaEdge, {
        key: key,
        name: key,
        schema: val,
        required: Array.isArray(schema.required)
          ? schema.required.includes(key)
          : false,
        discriminator: discriminator,
        schemaType: schemaType,
        schemaPath: schemaPath ? `${schemaPath}.${key}` : undefined,
      })
    )
  );
};
const PropertyDiscriminator = ({
  name,
  schemaName,
  schema,
  schemaType,
  discriminator,
  required,
}) => {
  if (!schema) {
    return null;
  }
  return react_1.default.createElement(
    react_1.default.Fragment,
    null,
    react_1.default.createElement(
      "div",
      { className: "openapi-discriminator__item openapi-schema__list-item" },
      react_1.default.createElement(
        "div",
        null,
        react_1.default.createElement(
          "span",
          { className: "openapi-schema__container" },
          react_1.default.createElement(
            "strong",
            {
              className: "openapi-discriminator__name openapi-schema__property",
            },
            name
          ),
          schemaName &&
            react_1.default.createElement(
              "span",
              { className: "openapi-schema__name" },
              " ",
              schemaName
            ),
          required &&
            react_1.default.createElement("span", {
              className: "openapi-schema__divider",
            }),
          required &&
            react_1.default.createElement(
              "span",
              { className: "openapi-schema__required" },
              (0, Translate_1.translate)({
                id: translationIds_1.OPENAPI_SCHEMA_ITEM.REQUIRED,
                message: "required",
              })
            )
        ),
        react_1.default.createElement(
          "div",
          { style: { marginLeft: "1rem" } },
          schema.description &&
            react_1.default.createElement(MarkdownWrapper, {
              text: schema.description,
            }),
          (0, schema_1.getQualifierMessage)(discriminator) &&
            react_1.default.createElement(MarkdownWrapper, {
              text: (0, schema_1.getQualifierMessage)(discriminator),
            })
        ),
        react_1.default.createElement(
          DiscriminatorTabs_1.default,
          { className: "openapi-tabs__discriminator" },
          Object.keys(discriminator.mapping).map((key, index) =>
            // @ts-ignore
            react_1.default.createElement(
              TabItem_1.default,
              { key: index, label: key, value: `${index}-item-discriminator` },
              react_1.default.createElement(SchemaNode, {
                schema: discriminator.mapping[key],
                schemaType: schemaType,
              })
            )
          )
        )
      )
    ),
    schema.properties &&
      Object.entries(schema.properties).map(
        ([key, val]) =>
          key !== discriminator.propertyName &&
          react_1.default.createElement(SchemaEdge, {
            key: key,
            name: key,
            schema: val,
            required: Array.isArray(schema.required)
              ? schema.required.includes(key)
              : false,
            discriminator: false,
            schemaType: schemaType,
          })
      )
  );
};
const DiscriminatorNode = ({ discriminator, schema, schemaType }) => {
  let discriminatedSchemas = {};
  let inferredMapping = {};
  // default to empty object if no parent-level properties exist
  const discriminatorProperty = schema.properties
    ? schema.properties[discriminator.propertyName]
    : {};
  if (schema.allOf) {
    const mergedSchemas = mergeAllOf(schema);
    if (mergedSchemas.oneOf || mergedSchemas.anyOf) {
      discriminatedSchemas = mergedSchemas.oneOf || mergedSchemas.anyOf;
    }
  } else if (schema.oneOf || schema.anyOf) {
    discriminatedSchemas = schema.oneOf || schema.anyOf;
  }
  // Handle case where no mapping is defined
  if (!discriminator.mapping) {
    Object.entries(discriminatedSchemas).forEach(([_, subschema], index) => {
      inferredMapping[subschema.title ?? `PROP${index}`] = subschema;
    });
    discriminator.mapping = inferredMapping;
  }
  // Merge sub schema discriminator property with parent
  Object.keys(discriminator.mapping).forEach((key) => {
    const subSchema = discriminator.mapping[key];
    // Handle discriminated schema with allOf
    let mergedSubSchema = {};
    if (subSchema.allOf) {
      mergedSubSchema = mergeAllOf(subSchema);
    }
    const subProperties = subSchema.properties || mergedSubSchema.properties;
    // Add a safeguard check to avoid referencing subProperties if it's undefined
    if (subProperties && subProperties[discriminator.propertyName]) {
      if (schema.properties) {
        schema.properties[discriminator.propertyName] = {
          ...schema.properties[discriminator.propertyName],
          ...subProperties[discriminator.propertyName],
        };
        if (subSchema.required && !schema.required) {
          schema.required = subSchema.required;
        }
        // Avoid duplicating property
        delete subProperties[discriminator.propertyName];
      } else {
        schema.properties = {};
        schema.properties[discriminator.propertyName] =
          subProperties[discriminator.propertyName];
        // Avoid duplicating property
        delete subProperties[discriminator.propertyName];
      }
    }
  });
  const name = discriminator.propertyName;
  const schemaName = (0, schema_1.getSchemaName)(discriminatorProperty);
  // Default case for discriminator without oneOf/anyOf/allOf
  return react_1.default.createElement(PropertyDiscriminator, {
    name: name,
    schemaName: schemaName,
    schema: schema,
    schemaType: schemaType,
    discriminator: discriminator,
    required: Array.isArray(schema.required)
      ? schema.required.includes(name)
      : schema.required,
  });
};
const AdditionalProperties = ({ schema, schemaType }) => {
  const additionalProperties = schema.additionalProperties;
  if (!additionalProperties) return null;
  // Handle free-form objects
  if (
    additionalProperties === true ||
    (0, isEmpty_1.default)(additionalProperties)
  ) {
    return react_1.default.createElement(SchemaItem_1.default, {
      name: "property name*",
      required: false,
      schemaName: "any",
      qualifierMessage: (0, schema_1.getQualifierMessage)(schema),
      schema: schema,
      collapsible: false,
      discriminator: false,
    });
  }
  // Handle objects, arrays, complex schemas
  if (
    additionalProperties.properties ||
    additionalProperties.items ||
    additionalProperties.allOf ||
    additionalProperties.additionalProperties ||
    additionalProperties.oneOf ||
    additionalProperties.anyOf
  ) {
    const title =
      additionalProperties.title ||
      (0, schema_1.getSchemaName)(additionalProperties);
    const required = schema.required || false;
    return react_1.default.createElement(SchemaNodeDetails, {
      name: "property name*",
      schemaName: title,
      required: required,
      nullable: schema.nullable,
      schema: additionalProperties,
      schemaType: schemaType,
    });
  }
  // Handle primitive types
  if (
    additionalProperties.type === "string" ||
    additionalProperties.type === "boolean" ||
    additionalProperties.type === "integer" ||
    additionalProperties.type === "number" ||
    additionalProperties.type === "object"
  ) {
    const schemaName = (0, schema_1.getSchemaName)(additionalProperties);
    return react_1.default.createElement(SchemaItem_1.default, {
      name: "property name*",
      required: false,
      schemaName: schemaName,
      qualifierMessage: (0, schema_1.getQualifierMessage)(schema),
      schema: additionalProperties,
      collapsible: false,
      discriminator: false,
      children: null,
    });
  }
  // Unknown type
  return null;
};
const SchemaNodeDetails = ({
  name,
  schemaName,
  schema,
  required,
  schemaType,
  schemaPath,
}) => {
  return react_1.default.createElement(
    SchemaItem_1.default,
    { collapsible: true },
    react_1.default.createElement(
      Details_1.default,
      {
        className: "openapi-markdown__details",
        summary: react_1.default.createElement(Summary, {
          name: name,
          schemaName: schemaName,
          schema: schema,
          required: required,
        }),
      },
      react_1.default.createElement(
        "div",
        { style: { marginLeft: "1rem" } },
        schema.description &&
          react_1.default.createElement(MarkdownWrapper, {
            text: schema.description,
          }),
        (0, schema_1.getQualifierMessage)(schema) &&
          react_1.default.createElement(MarkdownWrapper, {
            text: (0, schema_1.getQualifierMessage)(schema),
          }),
        react_1.default.createElement(SchemaNode, {
          schema: schema,
          schemaType: schemaType,
          schemaPath: schemaPath,
        })
      )
    )
  );
};
const Items = ({ schema, schemaType, schemaPath }) => {
  // Process schema.items to handle allOf merging
  let itemsSchema = schema.items;
  if (schema.items?.allOf) {
    itemsSchema = mergeAllOf(schema.items);
  }
  // Handle complex schemas with multiple schema types
  const hasOneOfAnyOf = itemsSchema?.oneOf || itemsSchema?.anyOf;
  const hasProperties = itemsSchema?.properties;
  const hasAdditionalProperties = itemsSchema?.additionalProperties;
  // Build the items schema path
  const itemsSchemaPath = schemaPath ? `${schemaPath}.items` : undefined;
  if (hasOneOfAnyOf || hasProperties || hasAdditionalProperties) {
    return react_1.default.createElement(
      react_1.default.Fragment,
      null,
      react_1.default.createElement(ArrayBrackets_1.OpeningArrayBracket, null),
      hasOneOfAnyOf &&
        react_1.default.createElement(AnyOneOf, {
          schema: itemsSchema,
          schemaType: schemaType,
          schemaPath: itemsSchemaPath,
        }),
      hasProperties &&
        react_1.default.createElement(Properties, {
          schema: itemsSchema,
          schemaType: schemaType,
          schemaPath: itemsSchemaPath,
        }),
      hasAdditionalProperties &&
        react_1.default.createElement(AdditionalProperties, {
          schema: itemsSchema,
          schemaType: schemaType,
        }),
      react_1.default.createElement(ArrayBrackets_1.ClosingArrayBracket, null)
    );
  }
  // Handles basic types (string, number, integer, boolean, object)
  if (
    itemsSchema?.type === "string" ||
    itemsSchema?.type === "number" ||
    itemsSchema?.type === "integer" ||
    itemsSchema?.type === "boolean" ||
    itemsSchema?.type === "object"
  ) {
    return react_1.default.createElement(
      "div",
      { style: { marginLeft: ".5rem" } },
      react_1.default.createElement(ArrayBrackets_1.OpeningArrayBracket, null),
      react_1.default.createElement(SchemaItem_1.default, {
        collapsible: false,
        name: "", // No name for array items
        schemaName: (0, schema_1.getSchemaName)(itemsSchema),
        qualifierMessage: (0, schema_1.getQualifierMessage)(itemsSchema),
        schema: itemsSchema,
        discriminator: false,
        children: null,
      }),
      react_1.default.createElement(ArrayBrackets_1.ClosingArrayBracket, null)
    );
  }
  // Handles fallback case (use createEdges logic)
  return react_1.default.createElement(
    react_1.default.Fragment,
    null,
    react_1.default.createElement(ArrayBrackets_1.OpeningArrayBracket, null),
    Object.entries(itemsSchema || {}).map(([key, val]) =>
      react_1.default.createElement(SchemaEdge, {
        key: key,
        name: key,
        schema: val,
        schemaType: schemaType,
        required: Array.isArray(schema.required)
          ? schema.required.includes(key)
          : false,
      })
    ),
    react_1.default.createElement(ArrayBrackets_1.ClosingArrayBracket, null)
  );
};
const SchemaEdge = ({
  name,
  schema,
  required,
  discriminator,
  schemaType,
  schemaPath,
}) => {
  if (
    (schemaType === "request" && schema.readOnly) ||
    (schemaType === "response" && schema.writeOnly)
  ) {
    return null;
  }
  const schemaName = (0, schema_1.getSchemaName)(schema);
  if (discriminator && discriminator.propertyName === name) {
    return react_1.default.createElement(PropertyDiscriminator, {
      name: name,
      schemaName: schemaName,
      schema: schema,
      schemaType: schemaType,
      discriminator: discriminator,
      required: required,
    });
  }
  if (schema.oneOf || schema.anyOf) {
    // return <AnyOneOf schema={schema} schemaType={schemaType} />;
    return react_1.default.createElement(SchemaNodeDetails, {
      name: name,
      schemaName: schemaName,
      schemaType: schemaType,
      required: required,
      schema: schema,
      nullable: schema.nullable,
      schemaPath: schemaPath,
    });
  }
  if (schema.properties) {
    return react_1.default.createElement(SchemaNodeDetails, {
      name: name,
      schemaName: schemaName,
      schemaType: schemaType,
      required: required,
      schema: schema,
      nullable: schema.nullable,
      schemaPath: schemaPath,
    });
  }
  if (schema.additionalProperties) {
    return react_1.default.createElement(SchemaNodeDetails, {
      name: name,
      schemaName: schemaName,
      schemaType: schemaType,
      required: required,
      schema: schema,
      nullable: schema.nullable,
      schemaPath: schemaPath,
    });
  }
  if (schema.items?.properties) {
    return react_1.default.createElement(SchemaNodeDetails, {
      name: name,
      schemaName: schemaName,
      required: required,
      nullable: schema.nullable,
      schema: schema,
      schemaType: schemaType,
      schemaPath: schemaPath,
    });
  }
  if (schema.items?.anyOf || schema.items?.oneOf || schema.items?.allOf) {
    return react_1.default.createElement(SchemaNodeDetails, {
      name: name,
      schemaName: schemaName,
      required: required,
      nullable: schema.nullable,
      schema: schema,
      schemaType: schemaType,
      schemaPath: schemaPath,
    });
  }
  if (schema.allOf) {
    // handle circular properties
    if (
      schema.allOf &&
      schema.allOf.length &&
      schema.allOf.length === 1 &&
      typeof schema.allOf[0] === "string"
    ) {
      return react_1.default.createElement(SchemaItem_1.default, {
        collapsible: false,
        name: name,
        required: Array.isArray(required) ? required.includes(name) : required,
        schemaName: schema.allOf[0],
        qualifierMessage: undefined,
        schema: schema.allOf[0],
        discriminator: false,
        children: null,
      });
    }
    const mergedSchemas = mergeAllOf(schema);
    if (
      (schemaType === "request" && mergedSchemas.readOnly) ||
      (schemaType === "response" && mergedSchemas.writeOnly)
    ) {
      return null;
    }
    const mergedSchemaName = (0, schema_1.getSchemaName)(mergedSchemas);
    if (mergedSchemas.oneOf || mergedSchemas.anyOf) {
      return react_1.default.createElement(SchemaNodeDetails, {
        name: name,
        schemaName: mergedSchemaName,
        required: Array.isArray(required) ? required.includes(name) : required,
        nullable: mergedSchemas.nullable,
        schema: mergedSchemas,
        schemaType: schemaType,
        schemaPath: schemaPath,
      });
    }
    if (mergedSchemas.properties !== undefined) {
      return react_1.default.createElement(SchemaNodeDetails, {
        name: name,
        schemaName: mergedSchemaName,
        required: Array.isArray(required) ? required.includes(name) : required,
        nullable: mergedSchemas.nullable,
        schema: mergedSchemas,
        schemaType: schemaType,
        schemaPath: schemaPath,
      });
    }
    if (mergedSchemas.items?.properties) {
      return react_1.default.createElement(SchemaNodeDetails, {
        name: name,
        schemaName: mergedSchemaName,
        required: Array.isArray(required) ? required.includes(name) : required,
        nullable: mergedSchemas.nullable,
        schema: mergedSchemas,
        schemaType: schemaType,
        schemaPath: schemaPath,
      });
    }
    return react_1.default.createElement(SchemaItem_1.default, {
      collapsible: false,
      name: name,
      required: Array.isArray(required) ? required.includes(name) : required,
      schemaName: mergedSchemaName,
      qualifierMessage: (0, schema_1.getQualifierMessage)(mergedSchemas),
      schema: mergedSchemas,
      discriminator: false,
      children: null,
    });
  }
  return react_1.default.createElement(SchemaItem_1.default, {
    collapsible: false,
    name: name,
    required: Array.isArray(required) ? required.includes(name) : required,
    schemaName: schemaName,
    qualifierMessage: (0, schema_1.getQualifierMessage)(schema),
    schema: schema,
    discriminator: false,
    children: null,
  });
};
function renderChildren(schema, schemaType, schemaPath) {
  return react_1.default.createElement(
    react_1.default.Fragment,
    null,
    schema.oneOf &&
      react_1.default.createElement(AnyOneOf, {
        schema: schema,
        schemaType: schemaType,
        schemaPath: schemaPath,
      }),
    schema.anyOf &&
      react_1.default.createElement(AnyOneOf, {
        schema: schema,
        schemaType: schemaType,
        schemaPath: schemaPath,
      }),
    schema.properties &&
      react_1.default.createElement(Properties, {
        schema: schema,
        schemaType: schemaType,
        schemaPath: schemaPath,
      }),
    schema.additionalProperties &&
      react_1.default.createElement(AdditionalProperties, {
        schema: schema,
        schemaType: schemaType,
      }),
    schema.items &&
      react_1.default.createElement(Items, {
        schema: schema,
        schemaType: schemaType,
        schemaPath: schemaPath,
      })
  );
}
const SchemaNode = ({ schema, schemaType, schemaPath }) => {
  if (
    (schemaType === "request" && schema.readOnly) ||
    (schemaType === "response" && schema.writeOnly)
  ) {
    return null;
  }
  if (schema.discriminator) {
    const { discriminator } = schema;
    return react_1.default.createElement(DiscriminatorNode, {
      discriminator: discriminator,
      schema: schema,
      schemaType: schemaType,
    });
  }
  // Handle allOf, oneOf, anyOf without discriminators
  if (schema.allOf) {
    // Check if allOf contains multiple oneOf/anyOf items that should be rendered separately
    const oneOfItems = schema.allOf.filter((item) => item.oneOf || item.anyOf);
    const hasMultipleChoices = oneOfItems.length > 1;
    if (hasMultipleChoices) {
      // Render each oneOf/anyOf constraint first, then shared properties
      const mergedSchemas = mergeAllOf(schema);
      if (
        (schemaType === "request" && mergedSchemas.readOnly) ||
        (schemaType === "response" && mergedSchemas.writeOnly)
      ) {
        return null;
      }
      return react_1.default.createElement(
        "div",
        null,
        schema.allOf.map((item, index) => {
          if (item.oneOf || item.anyOf) {
            const itemSchemaPath = schemaPath
              ? `${schemaPath}.allOf.${index}`
              : undefined;
            return react_1.default.createElement(
              "div",
              { key: index },
              react_1.default.createElement(AnyOneOf, {
                schema: item,
                schemaType: schemaType,
                schemaPath: itemSchemaPath,
              })
            );
          }
          return null;
        }),
        mergedSchemas.properties &&
          react_1.default.createElement(Properties, {
            schema: mergedSchemas,
            schemaType: schemaType,
            schemaPath: schemaPath,
          }),
        mergedSchemas.items &&
          react_1.default.createElement(Items, {
            schema: mergedSchemas,
            schemaType: schemaType,
            schemaPath: schemaPath,
          })
      );
    }
    // For other allOf cases, use standard merge behavior
    const mergedSchemas = mergeAllOf(schema);
    if (
      (schemaType === "request" && mergedSchemas.readOnly) ||
      (schemaType === "response" && mergedSchemas.writeOnly)
    ) {
      return null;
    }
    return react_1.default.createElement(
      "div",
      null,
      mergedSchemas.oneOf &&
        react_1.default.createElement(AnyOneOf, {
          schema: mergedSchemas,
          schemaType: schemaType,
          schemaPath: schemaPath,
        }),
      mergedSchemas.anyOf &&
        react_1.default.createElement(AnyOneOf, {
          schema: mergedSchemas,
          schemaType: schemaType,
          schemaPath: schemaPath,
        }),
      mergedSchemas.properties &&
        react_1.default.createElement(Properties, {
          schema: mergedSchemas,
          schemaType: schemaType,
          schemaPath: schemaPath,
        }),
      mergedSchemas.items &&
        react_1.default.createElement(Items, {
          schema: mergedSchemas,
          schemaType: schemaType,
          schemaPath: schemaPath,
        })
    );
  }
  // Handle primitives
  if (
    schema.type &&
    !schema.oneOf &&
    !schema.anyOf &&
    !schema.properties &&
    !schema.allOf &&
    !schema.items &&
    !schema.additionalProperties
  ) {
    const schemaName = (0, schema_1.getSchemaName)(schema);
    return react_1.default.createElement(SchemaItem_1.default, {
      collapsible: false,
      name: schema.type,
      required: Boolean(schema.required),
      schemaName: schemaName,
      qualifierMessage: (0, schema_1.getQualifierMessage)(schema),
      schema: schema,
      discriminator: false,
      children: null,
    });
  }
  return renderChildren(schema, schemaType, schemaPath);
};
exports.default = SchemaNode;
const PRIMITIVE_TYPES = {
  string: true,
  number: true,
  integer: true,
  boolean: true,
  null: true,
};
const isPrimitive = (schema) => {
  // Enum-only schemas (without explicit type) should be treated as primitives
  // This is valid JSON Schema where enum values define the constraints
  if (schema.enum && !schema.type) {
    return true;
  }
  return PRIMITIVE_TYPES[schema.type];
};
