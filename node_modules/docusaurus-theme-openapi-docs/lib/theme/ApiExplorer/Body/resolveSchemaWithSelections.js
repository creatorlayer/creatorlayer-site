"use strict";
/* ============================================================================
 * Copyright (c) Palo Alto Networks
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 * ========================================================================== */
var __importDefault =
  (this && this.__importDefault) ||
  function (mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
Object.defineProperty(exports, "__esModule", { value: true });
exports.resolveSchemaWithSelections = resolveSchemaWithSelections;
const merge_1 = __importDefault(require("lodash/merge"));
/**
 * Resolves a schema by replacing anyOf/oneOf with the selected option based on user selections.
 *
 * @param schema - The original schema object
 * @param selections - Map of schema paths to selected indices
 * @param basePath - The base path for this schema (used for looking up selections)
 * @returns A new schema with anyOf/oneOf resolved to selected options
 */
function resolveSchemaWithSelections(
  schema,
  selections,
  basePath = "requestBody"
) {
  if (!schema) {
    return schema;
  }
  // Deep clone to avoid mutating the original schema
  const schemaCopy = JSON.parse(JSON.stringify(schema));
  return resolveSchemaRecursive(schemaCopy, selections, basePath);
}
function resolveSchemaRecursive(schema, selections, currentPath) {
  // Handle oneOf
  if (schema.oneOf && Array.isArray(schema.oneOf)) {
    const selectedIndex = selections[currentPath] ?? 0;
    const selectedSchema = schema.oneOf[selectedIndex];
    if (selectedSchema) {
      // If there are shared properties, merge them with the selected schema
      if (schema.properties) {
        const mergedSchema = (0, merge_1.default)({}, schema, selectedSchema);
        delete mergedSchema.oneOf;
        // Continue resolving nested schemas in the merged result
        return resolveSchemaRecursive(
          mergedSchema,
          selections,
          `${currentPath}.${selectedIndex}`
        );
      }
      // No shared properties, just use the selected schema
      // Continue resolving in case there are nested anyOf/oneOf
      return resolveSchemaRecursive(
        selectedSchema,
        selections,
        `${currentPath}.${selectedIndex}`
      );
    }
  }
  // Handle anyOf
  if (schema.anyOf && Array.isArray(schema.anyOf)) {
    const selectedIndex = selections[currentPath] ?? 0;
    const selectedSchema = schema.anyOf[selectedIndex];
    if (selectedSchema) {
      // If there are shared properties, merge them with the selected schema
      if (schema.properties) {
        const mergedSchema = (0, merge_1.default)({}, schema, selectedSchema);
        delete mergedSchema.anyOf;
        // Continue resolving nested schemas in the merged result
        return resolveSchemaRecursive(
          mergedSchema,
          selections,
          `${currentPath}.${selectedIndex}`
        );
      }
      // No shared properties, just use the selected schema
      // Continue resolving in case there are nested anyOf/oneOf
      return resolveSchemaRecursive(
        selectedSchema,
        selections,
        `${currentPath}.${selectedIndex}`
      );
    }
  }
  // Handle allOf - merge all schemas and continue resolving
  if (schema.allOf && Array.isArray(schema.allOf)) {
    // Process each allOf item, resolving any anyOf/oneOf within them
    const resolvedItems = schema.allOf.map((item, index) => {
      return resolveSchemaRecursive(
        item,
        selections,
        `${currentPath}.allOf.${index}`
      );
    });
    // Merge all resolved items
    const mergedSchema = resolvedItems.reduce(
      (acc, item) => (0, merge_1.default)(acc, item),
      {}
    );
    // Preserve any top-level properties from the original schema
    if (schema.properties) {
      mergedSchema.properties = (0, merge_1.default)(
        {},
        mergedSchema.properties,
        schema.properties
      );
    }
    return mergedSchema;
  }
  // Handle object properties recursively
  if (schema.properties) {
    const resolvedProperties = {};
    for (const [propName, propSchema] of Object.entries(schema.properties)) {
      resolvedProperties[propName] = resolveSchemaRecursive(
        propSchema,
        selections,
        `${currentPath}.${propName}`
      );
    }
    schema.properties = resolvedProperties;
  }
  // Handle array items recursively
  if (schema.items) {
    schema.items = resolveSchemaRecursive(
      schema.items,
      selections,
      `${currentPath}.items`
    );
  }
  return schema;
}
